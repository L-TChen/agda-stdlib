<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.MonoidSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Reflection-based solver for monoid equalities</a>
<a id="155" class="Comment">------------------------------------------------------------------------</a>
<a id="228" class="Comment">--</a>
<a id="231" class="Comment">-- This solver automates the construction of proofs of equivalences</a>
<a id="299" class="Comment">-- between monoid expressions.</a>
<a id="330" class="Comment">-- When called like so:</a>
<a id="354" class="Comment">--</a>
<a id="357" class="Comment">--   proof : ∀ x y z → (x ∙ y) ∙ z ≈ x ∙ (y ∙ z) ∙ ε</a>
<a id="410" class="Comment">--   proof x y z = solve mon</a>
<a id="439" class="Comment">--</a>
<a id="442" class="Comment">-- The following diagram describes what happens under the hood:</a>
<a id="506" class="Comment">--</a>
<a id="509" class="Comment">--            ┌▸x ∙ (y ∙ (z ∙ ε)) ════ x ∙ (y ∙ (z ∙ ε))◂┐</a>
<a id="568" class="Comment">--            │         ║                      ║         │</a>
<a id="627" class="Comment">--            │         ║                      ║         │</a>
<a id="686" class="Comment">--          [_⇓]        ║                      ║        [_⇓]</a>
<a id="747" class="Comment">--          ╱           ║                      ║          ╲</a>
<a id="807" class="Comment">--         ╱            ║                      ║           ╲</a>
<a id="868" class="Comment">-- (x ∙′ y) ∙′ z      homo                   homo    x ∙′ (y ∙′ z) ∙′ ε′</a>
<a id="941" class="Comment">--   ▴     ╲            ║                      ║           ╱       ▴</a>
<a id="1010" class="Comment">--   │      ╲           ║                      ║          ╱        │</a>
<a id="1079" class="Comment">--   │       [_↓]       ║                      ║        [_↓]       │</a>
<a id="1148" class="Comment">--   │        │         ║                      ║         │         │</a>
<a id="1217" class="Comment">--   │        │         ║                      ║         │         │</a>
<a id="1286" class="Comment">--   │        └───▸(x ∙ y) ∙ z          x ∙ (y ∙ z) ∙ ε◂─┘         │</a>
<a id="1355" class="Comment">--   │                  │                      │                   │</a>
<a id="1424" class="Comment">--   │                  │                      │                   │</a>
<a id="1493" class="Comment">--   └────reflection────┘                      └───reflection──────┘</a>
<a id="1562" class="Comment">--</a>
<a id="1565" class="Comment">-- The actual output—the proof constructed by the solver—is represented</a>
<a id="1637" class="Comment">-- by the double-lined path (══).</a>
<a id="1671" class="Comment">--</a>
<a id="1674" class="Comment">-- We start at the bottom, with our two expressions.</a>
<a id="1727" class="Comment">-- Through reflection, we convert these two expressions to their AST</a>
<a id="1796" class="Comment">-- representations, in the Expr type.</a>
<a id="1834" class="Comment">-- We then can evaluate the AST in two ways: one simply gives us back</a>
<a id="1904" class="Comment">-- the two expressions we put in ([_↓]), and the other normalises</a>
<a id="1970" class="Comment">-- ([_⇓]).</a>
<a id="1981" class="Comment">-- We use the homo function to prove equivalence between these two</a>
<a id="2048" class="Comment">-- forms: joining up these two proofs gives us the desired overall</a>
<a id="2115" class="Comment">-- proof.</a>

<a id="2126" class="Comment">-- Note: What&#39;s going on with the Monoid parameter?</a>
<a id="2178" class="Comment">--</a>
<a id="2181" class="Comment">-- This module is not parameterised over a monoid, which is contrary</a>
<a id="2250" class="Comment">-- to what you might expect. Instead, we take the monoid record as an</a>
<a id="2320" class="Comment">-- argument to the solve macro, and then pass it around as an</a>
<a id="2382" class="Comment">-- argument wherever we need it.</a>
<a id="2415" class="Comment">--</a>
<a id="2418" class="Comment">-- We need to get the monoid record at the call site, not the import</a>
<a id="2487" class="Comment">-- site, to ensure that it&#39;s consistent with the rest of the context.</a>
<a id="2557" class="Comment">-- For instance, if we wanted to produce `x ∙ y` using the monoid record</a>
<a id="2630" class="Comment">-- as imported, we would run into problems:</a>
<a id="2674" class="Comment">-- * If we tried to just reflect on the expression itself</a>
<a id="2732" class="Comment">--   (quoteTerm (x ∙ y)) we would likely get some de Bruijn indices</a>
<a id="2800" class="Comment">--   wrong (in x and y), and ∙ might not even be in scope where the</a>
<a id="2868" class="Comment">--   user wants us to solve! If they&#39;re solving an expression like</a>
<a id="2935" class="Comment">--   x + (y + z), they can pass in the +-0-monoid, but don&#39;t have to</a>
<a id="3004" class="Comment">--   open it themselves.</a>
<a id="3029" class="Comment">-- * If instead we tried to construct a term which accesses the _∙_</a>
<a id="3097" class="Comment">--   field on the reflection of the record, we&#39;d run into similar</a>
<a id="3163" class="Comment">--   problems again. While the record is a parameter for us, it might</a>
<a id="3233" class="Comment">--   not be for the user.</a>
<a id="3259" class="Comment">-- Basically, we need the Monoid we&#39;re looking at to be exactly the</a>
<a id="3327" class="Comment">-- same as the one the user is looking at, and in order to do that we</a>
<a id="3397" class="Comment">-- quote it at the call site.</a>

<a id="3428" class="Symbol">{-#</a> <a id="3432" class="Keyword">OPTIONS</a> <a id="3440" class="Pragma">--cubical-compatible</a> <a id="3461" class="Pragma">--safe</a> <a id="3468" class="Symbol">#-}</a>

<a id="3473" class="Keyword">module</a> <a id="3480" href="Tactic.MonoidSolver.html" class="Module">Tactic.MonoidSolver</a> <a id="3500" class="Keyword">where</a>

<a id="3507" class="Keyword">open</a> <a id="3512" class="Keyword">import</a> <a id="3519" href="Algebra.html" class="Module">Algebra</a>
<a id="3527" class="Keyword">open</a> <a id="3532" class="Keyword">import</a> <a id="3539" href="Function.html" class="Module">Function</a>

<a id="3549" class="Keyword">open</a> <a id="3554" class="Keyword">import</a> <a id="3561" href="Data.Bool.html" class="Module">Data.Bool</a>    <a id="3574" class="Symbol">as</a> <a id="3577" class="Module">Bool</a>    <a id="3585" class="Keyword">using</a> <a id="3591" class="Symbol">(</a><a id="3592" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="3596" class="Symbol">;</a> <a id="3598" href="Data.Bool.Base.html#1053" class="Function Operator">_∨_</a><a id="3601" class="Symbol">;</a> <a id="3603" href="Data.Bool.Base.html#1292" class="Function Operator">if_then_else_</a><a id="3616" class="Symbol">)</a>
<a id="3618" class="Keyword">open</a> <a id="3623" class="Keyword">import</a> <a id="3630" href="Data.Maybe.html" class="Module">Data.Maybe</a>   <a id="3643" class="Symbol">as</a> <a id="3646" class="Module">Maybe</a>   <a id="3654" class="Keyword">using</a> <a id="3660" class="Symbol">(</a><a id="3661" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a><a id="3666" class="Symbol">;</a> <a id="3668" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a><a id="3672" class="Symbol">;</a> <a id="3674" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a><a id="3681" class="Symbol">;</a> <a id="3683" href="Data.Maybe.Base.html#1386" class="Function">maybe</a><a id="3688" class="Symbol">)</a>
<a id="3690" class="Keyword">open</a> <a id="3695" class="Keyword">import</a> <a id="3702" href="Data.List.html" class="Module">Data.List</a>    <a id="3715" class="Symbol">as</a> <a id="3718" class="Module">List</a>    <a id="3726" class="Keyword">using</a> <a id="3732" class="Symbol">(</a><a id="3733" href="Agda.Builtin.List.html#130" class="Datatype">List</a><a id="3737" class="Symbol">;</a> <a id="3739" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">_∷_</a><a id="3742" class="Symbol">;</a> <a id="3744" href="Data.List.Base.html#7370" class="InductiveConstructor">[]</a><a id="3746" class="Symbol">)</a>
<a id="3748" class="Keyword">open</a> <a id="3753" class="Keyword">import</a> <a id="3760" href="Data.Nat.html" class="Module">Data.Nat</a>     <a id="3773" class="Symbol">as</a> <a id="3776" class="Module">ℕ</a>       <a id="3784" class="Keyword">using</a> <a id="3790" class="Symbol">(</a><a id="3791" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="3792" class="Symbol">;</a> <a id="3794" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="3797" class="Symbol">;</a> <a id="3799" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="3803" class="Symbol">)</a>
<a id="3805" class="Keyword">open</a> <a id="3810" class="Keyword">import</a> <a id="3817" href="Data.Product.html" class="Module">Data.Product</a> <a id="3830" class="Symbol">as</a> <a id="3833" class="Module">Product</a> <a id="3841" class="Keyword">using</a> <a id="3847" class="Symbol">(</a><a id="3848" href="Data.Product.Base.html#1118" class="Function Operator">_×_</a><a id="3851" class="Symbol">;</a> <a id="3853" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a><a id="3856" class="Symbol">)</a>

<a id="3859" class="Keyword">open</a> <a id="3864" class="Keyword">import</a> <a id="3871" href="Reflection.AST.html" class="Module">Reflection.AST</a>
<a id="3886" class="Keyword">open</a> <a id="3891" class="Keyword">import</a> <a id="3898" href="Reflection.AST.Term.html" class="Module">Reflection.AST.Term</a>
<a id="3918" class="Keyword">open</a> <a id="3923" class="Keyword">import</a> <a id="3930" href="Reflection.AST.Argument.html" class="Module">Reflection.AST.Argument</a>
<a id="3954" class="Keyword">import</a> <a id="3961" href="Reflection.AST.Name.html" class="Module">Reflection.AST.Name</a> <a id="3981" class="Symbol">as</a> <a id="3984" class="Module">Name</a>
<a id="3989" class="Keyword">open</a> <a id="3994" class="Keyword">import</a> <a id="4001" href="Reflection.TCM.html" class="Module">Reflection.TCM</a>
<a id="4016" class="Keyword">open</a> <a id="4021" class="Keyword">import</a> <a id="4028" href="Reflection.TCM.Syntax.html" class="Module">Reflection.TCM.Syntax</a>

<a id="4051" class="Keyword">import</a> <a id="4058" href="Relation.Binary.Reasoning.Setoid.html" class="Module">Relation.Binary.Reasoning.Setoid</a> <a id="4091" class="Symbol">as</a> <a id="4094" class="Module">SetoidReasoning</a>

<a id="4111" class="Comment">----------------------------------------------------------------------</a>
<a id="4182" class="Comment">-- The Expr type with homomorphism proofs</a>
<a id="4224" class="Comment">----------------------------------------------------------------------</a>

<a id="4296" class="Keyword">infixl</a> <a id="4303" class="Number">7</a> <a id="4305" href="Tactic.MonoidSolver.html#4352" class="InductiveConstructor Operator">_∙′_</a>
<a id="4310" class="Keyword">data</a> <a id="Expr"></a><a id="4315" href="Tactic.MonoidSolver.html#4315" class="Datatype">Expr</a> <a id="4320" class="Symbol">{</a><a id="4321" href="Tactic.MonoidSolver.html#4321" class="Bound">a</a><a id="4322" class="Symbol">}</a> <a id="4324" class="Symbol">(</a><a id="4325" href="Tactic.MonoidSolver.html#4325" class="Bound">A</a> <a id="4327" class="Symbol">:</a> <a id="4329" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="4333" href="Tactic.MonoidSolver.html#4321" class="Bound">a</a><a id="4334" class="Symbol">)</a> <a id="4336" class="Symbol">:</a> <a id="4338" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="4342" href="Tactic.MonoidSolver.html#4321" class="Bound">a</a> <a id="4344" class="Keyword">where</a>
  <a id="Expr._∙′_"></a><a id="4352" href="Tactic.MonoidSolver.html#4352" class="InductiveConstructor Operator">_∙′_</a>  <a id="4358" class="Symbol">:</a> <a id="4360" href="Tactic.MonoidSolver.html#4315" class="Datatype">Expr</a> <a id="4365" href="Tactic.MonoidSolver.html#4325" class="Bound">A</a> <a id="4367" class="Symbol">→</a> <a id="4369" href="Tactic.MonoidSolver.html#4315" class="Datatype">Expr</a> <a id="4374" href="Tactic.MonoidSolver.html#4325" class="Bound">A</a> <a id="4376" class="Symbol">→</a> <a id="4378" href="Tactic.MonoidSolver.html#4315" class="Datatype">Expr</a> <a id="4383" href="Tactic.MonoidSolver.html#4325" class="Bound">A</a>
  <a id="Expr.ε′"></a><a id="4387" href="Tactic.MonoidSolver.html#4387" class="InductiveConstructor">ε′</a>    <a id="4393" class="Symbol">:</a> <a id="4395" href="Tactic.MonoidSolver.html#4315" class="Datatype">Expr</a> <a id="4400" href="Tactic.MonoidSolver.html#4325" class="Bound">A</a>
  <a id="Expr.[_↑]"></a><a id="4404" href="Tactic.MonoidSolver.html#4404" class="InductiveConstructor Operator">[_↑]</a>  <a id="4410" class="Symbol">:</a> <a id="4412" href="Tactic.MonoidSolver.html#4325" class="Bound">A</a> <a id="4414" class="Symbol">→</a> <a id="4416" href="Tactic.MonoidSolver.html#4315" class="Datatype">Expr</a> <a id="4421" href="Tactic.MonoidSolver.html#4325" class="Bound">A</a>

<a id="4424" class="Keyword">module</a> <a id="4431" href="Tactic.MonoidSolver.html#4431" class="Module">_</a> <a id="4433" class="Symbol">{</a><a id="4434" href="Tactic.MonoidSolver.html#4434" class="Bound">m₁</a> <a id="4437" href="Tactic.MonoidSolver.html#4437" class="Bound">m₂</a><a id="4439" class="Symbol">}</a> <a id="4441" class="Symbol">(</a><a id="4442" href="Tactic.MonoidSolver.html#4442" class="Bound">monoid</a> <a id="4449" class="Symbol">:</a> <a id="4451" href="Algebra.Bundles.html#6016" class="Record">Monoid</a> <a id="4458" href="Tactic.MonoidSolver.html#4434" class="Bound">m₁</a> <a id="4461" href="Tactic.MonoidSolver.html#4437" class="Bound">m₂</a><a id="4463" class="Symbol">)</a> <a id="4465" class="Keyword">where</a>

  <a id="4474" class="Keyword">open</a> <a id="4479" href="Algebra.Bundles.html#6016" class="Module">Monoid</a> <a id="4486" href="Tactic.MonoidSolver.html#4442" class="Bound">monoid</a>
  <a id="4495" class="Keyword">open</a> <a id="4500" href="Relation.Binary.Reasoning.Setoid.html" class="Module">SetoidReasoning</a> <a id="4516" href="Algebra.Structures.html#1291" class="Function">setoid</a>

  <a id="4526" class="Comment">-- Convert the AST to an expression (i.e. evaluate it) without</a>
  <a id="4591" class="Comment">-- normalising.</a>
  <a id="4609" href="Tactic.MonoidSolver.html#4609" class="Function Operator">[_↓]</a> <a id="4614" class="Symbol">:</a> <a id="4616" href="Tactic.MonoidSolver.html#4315" class="Datatype">Expr</a> <a id="4621" href="Algebra.Bundles.html#6095" class="Field">Carrier</a> <a id="4629" class="Symbol">→</a> <a id="4631" href="Algebra.Bundles.html#6095" class="Field">Carrier</a>
  <a id="4641" href="Tactic.MonoidSolver.html#4609" class="Function Operator">[</a> <a id="4643" href="Tactic.MonoidSolver.html#4643" class="Bound">x</a> <a id="4645" href="Tactic.MonoidSolver.html#4352" class="InductiveConstructor Operator">∙′</a> <a id="4648" href="Tactic.MonoidSolver.html#4648" class="Bound">y</a>  <a id="4651" href="Tactic.MonoidSolver.html#4609" class="Function Operator">↓]</a> <a id="4654" class="Symbol">=</a> <a id="4656" href="Tactic.MonoidSolver.html#4609" class="Function Operator">[</a> <a id="4658" href="Tactic.MonoidSolver.html#4643" class="Bound">x</a> <a id="4660" href="Tactic.MonoidSolver.html#4609" class="Function Operator">↓]</a> <a id="4663" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="4665" href="Tactic.MonoidSolver.html#4609" class="Function Operator">[</a> <a id="4667" href="Tactic.MonoidSolver.html#4648" class="Bound">y</a> <a id="4669" href="Tactic.MonoidSolver.html#4609" class="Function Operator">↓]</a>
  <a id="4674" href="Tactic.MonoidSolver.html#4609" class="Function Operator">[</a> <a id="4676" href="Tactic.MonoidSolver.html#4387" class="InductiveConstructor">ε′</a>      <a id="4684" href="Tactic.MonoidSolver.html#4609" class="Function Operator">↓]</a> <a id="4687" class="Symbol">=</a> <a id="4689" href="Algebra.Bundles.html#6172" class="Field">ε</a>
  <a id="4693" href="Tactic.MonoidSolver.html#4609" class="Function Operator">[</a> <a id="4695" href="Tactic.MonoidSolver.html#4404" class="InductiveConstructor Operator">[</a> <a id="4697" href="Tactic.MonoidSolver.html#4697" class="Bound">x</a> <a id="4699" href="Tactic.MonoidSolver.html#4404" class="InductiveConstructor Operator">↑]</a>  <a id="4703" href="Tactic.MonoidSolver.html#4609" class="Function Operator">↓]</a> <a id="4706" class="Symbol">=</a> <a id="4708" href="Tactic.MonoidSolver.html#4697" class="Bound">x</a>

  <a id="4713" class="Comment">-- Convert an AST to an expression (i.e. evaluate it) while</a>
  <a id="4775" class="Comment">-- normalising.</a>
  <a id="4793" class="Comment">--</a>
  <a id="4798" class="Comment">-- This first function actually converts an AST to the Cayley</a>
  <a id="4862" class="Comment">-- representation of the underlying monoid.</a>
  <a id="4908" class="Comment">-- This obeys the monoid laws up to beta-eta equality, which is the</a>
  <a id="4978" class="Comment">-- property which gives us the &quot;normalising&quot; behaviour we want.</a>
  <a id="5044" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[_⇓]′</a> <a id="5050" class="Symbol">:</a> <a id="5052" href="Tactic.MonoidSolver.html#4315" class="Datatype">Expr</a> <a id="5057" href="Algebra.Bundles.html#6095" class="Field">Carrier</a> <a id="5065" class="Symbol">→</a> <a id="5067" href="Algebra.Bundles.html#6095" class="Field">Carrier</a> <a id="5075" class="Symbol">→</a> <a id="5077" href="Algebra.Bundles.html#6095" class="Field">Carrier</a>
  <a id="5087" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5089" href="Tactic.MonoidSolver.html#5089" class="Bound">x</a> <a id="5091" href="Tactic.MonoidSolver.html#4352" class="InductiveConstructor Operator">∙′</a> <a id="5094" href="Tactic.MonoidSolver.html#5094" class="Bound">y</a>  <a id="5097" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5101" href="Tactic.MonoidSolver.html#5101" class="Bound">z</a> <a id="5103" class="Symbol">=</a> <a id="5105" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5107" href="Tactic.MonoidSolver.html#5089" class="Bound">x</a> <a id="5109" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5113" class="Symbol">(</a><a id="5114" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5116" href="Tactic.MonoidSolver.html#5094" class="Bound">y</a> <a id="5118" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5122" href="Tactic.MonoidSolver.html#5101" class="Bound">z</a><a id="5123" class="Symbol">)</a>
  <a id="5127" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5129" href="Tactic.MonoidSolver.html#4387" class="InductiveConstructor">ε′</a>      <a id="5137" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5141" href="Tactic.MonoidSolver.html#5141" class="Bound">y</a> <a id="5143" class="Symbol">=</a> <a id="5145" href="Tactic.MonoidSolver.html#5141" class="Bound">y</a>
  <a id="5149" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5151" href="Tactic.MonoidSolver.html#4404" class="InductiveConstructor Operator">[</a> <a id="5153" href="Tactic.MonoidSolver.html#5153" class="Bound">x</a> <a id="5155" href="Tactic.MonoidSolver.html#4404" class="InductiveConstructor Operator">↑]</a>  <a id="5159" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5163" href="Tactic.MonoidSolver.html#5163" class="Bound">y</a> <a id="5165" class="Symbol">=</a> <a id="5167" href="Tactic.MonoidSolver.html#5153" class="Bound">x</a> <a id="5169" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5171" href="Tactic.MonoidSolver.html#5163" class="Bound">y</a>

  <a id="5176" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[_⇓]</a> <a id="5181" class="Symbol">:</a> <a id="5183" href="Tactic.MonoidSolver.html#4315" class="Datatype">Expr</a> <a id="5188" href="Algebra.Bundles.html#6095" class="Field">Carrier</a> <a id="5196" class="Symbol">→</a> <a id="5198" href="Algebra.Bundles.html#6095" class="Field">Carrier</a>
  <a id="5208" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5210" href="Tactic.MonoidSolver.html#5210" class="Bound">x</a> <a id="5212" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5215" class="Symbol">=</a> <a id="5217" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5219" href="Tactic.MonoidSolver.html#5210" class="Bound">x</a> <a id="5221" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5225" href="Algebra.Bundles.html#6172" class="Field">ε</a>

  <a id="5230" href="Tactic.MonoidSolver.html#5230" class="Function">homo′</a> <a id="5236" class="Symbol">:</a> <a id="5238" class="Symbol">∀</a> <a id="5240" href="Tactic.MonoidSolver.html#5240" class="Bound">x</a> <a id="5242" href="Tactic.MonoidSolver.html#5242" class="Bound">y</a> <a id="5244" class="Symbol">→</a> <a id="5246" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5248" href="Tactic.MonoidSolver.html#5240" class="Bound">x</a> <a id="5250" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5253" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5255" href="Tactic.MonoidSolver.html#5242" class="Bound">y</a> <a id="5257" href="Algebra.Bundles.html#6116" class="Field Operator">≈</a> <a id="5259" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5261" href="Tactic.MonoidSolver.html#5240" class="Bound">x</a> <a id="5263" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5267" href="Tactic.MonoidSolver.html#5242" class="Bound">y</a>
  <a id="5271" href="Tactic.MonoidSolver.html#5230" class="Function">homo′</a> <a id="5277" href="Tactic.MonoidSolver.html#4387" class="InductiveConstructor">ε′</a> <a id="5280" href="Tactic.MonoidSolver.html#5280" class="Bound">y</a>       <a id="5288" class="Symbol">=</a> <a id="5290" href="Algebra.Structures.html#4037" class="Function">identityˡ</a> <a id="5300" href="Tactic.MonoidSolver.html#5280" class="Bound">y</a>
  <a id="5304" href="Tactic.MonoidSolver.html#5230" class="Function">homo′</a> <a id="5310" href="Tactic.MonoidSolver.html#4404" class="InductiveConstructor Operator">[</a> <a id="5312" href="Tactic.MonoidSolver.html#5312" class="Bound">x</a> <a id="5314" href="Tactic.MonoidSolver.html#4404" class="InductiveConstructor Operator">↑]</a> <a id="5317" href="Tactic.MonoidSolver.html#5317" class="Bound">y</a>   <a id="5321" class="Symbol">=</a> <a id="5323" href="Algebra.Structures.html#1427" class="Function">∙-congʳ</a> <a id="5331" class="Symbol">(</a><a id="5332" href="Algebra.Structures.html#4098" class="Function">identityʳ</a> <a id="5342" href="Tactic.MonoidSolver.html#5312" class="Bound">x</a><a id="5343" class="Symbol">)</a>
  <a id="5347" href="Tactic.MonoidSolver.html#5230" class="Function">homo′</a> <a id="5353" class="Symbol">(</a><a id="5354" href="Tactic.MonoidSolver.html#5354" class="Bound">x</a> <a id="5356" href="Tactic.MonoidSolver.html#4352" class="InductiveConstructor Operator">∙′</a> <a id="5359" href="Tactic.MonoidSolver.html#5359" class="Bound">y</a><a id="5360" class="Symbol">)</a> <a id="5362" href="Tactic.MonoidSolver.html#5362" class="Bound">z</a> <a id="5364" class="Symbol">=</a> <a id="5366" href="Relation.Binary.Reasoning.Base.Single.html#1925" class="Function Operator">begin</a>
    <a id="5376" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5378" href="Tactic.MonoidSolver.html#5354" class="Bound">x</a> <a id="5380" href="Tactic.MonoidSolver.html#4352" class="InductiveConstructor Operator">∙′</a> <a id="5383" href="Tactic.MonoidSolver.html#5359" class="Bound">y</a> <a id="5385" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5388" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5390" href="Tactic.MonoidSolver.html#5362" class="Bound">z</a>       <a id="5398" href="Relation.Binary.Reasoning.Base.Single.html#2479" class="Function Operator">≡⟨⟩</a>
    <a id="5406" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5408" href="Tactic.MonoidSolver.html#5354" class="Bound">x</a> <a id="5410" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5414" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5416" href="Tactic.MonoidSolver.html#5359" class="Bound">y</a> <a id="5418" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5421" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5423" href="Tactic.MonoidSolver.html#5362" class="Bound">z</a>    <a id="5428" href="Relation.Binary.Reasoning.Setoid.html#1162" class="Function">≈˘⟨</a> <a id="5432" href="Algebra.Structures.html#1427" class="Function">∙-congʳ</a> <a id="5440" class="Symbol">(</a><a id="5441" href="Tactic.MonoidSolver.html#5230" class="Function">homo′</a> <a id="5447" href="Tactic.MonoidSolver.html#5354" class="Bound">x</a> <a id="5449" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5451" href="Tactic.MonoidSolver.html#5359" class="Bound">y</a> <a id="5453" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a><a id="5455" class="Symbol">)</a> <a id="5457" href="Relation.Binary.Reasoning.Setoid.html#1162" class="Function">⟩</a>
    <a id="5463" class="Symbol">(</a><a id="5464" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5466" href="Tactic.MonoidSolver.html#5354" class="Bound">x</a> <a id="5468" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5471" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5473" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5475" href="Tactic.MonoidSolver.html#5359" class="Bound">y</a> <a id="5477" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a><a id="5479" class="Symbol">)</a> <a id="5481" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5483" href="Tactic.MonoidSolver.html#5362" class="Bound">z</a> <a id="5485" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">≈⟨</a> <a id="5488" href="Algebra.Structures.html#2878" class="Function">assoc</a> <a id="5494" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5496" href="Tactic.MonoidSolver.html#5354" class="Bound">x</a> <a id="5498" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5501" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5503" href="Tactic.MonoidSolver.html#5359" class="Bound">y</a> <a id="5505" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5508" href="Tactic.MonoidSolver.html#5362" class="Bound">z</a> <a id="5510" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">⟩</a>
    <a id="5516" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5518" href="Tactic.MonoidSolver.html#5354" class="Bound">x</a> <a id="5520" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5523" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5525" class="Symbol">(</a><a id="5526" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5528" href="Tactic.MonoidSolver.html#5359" class="Bound">y</a> <a id="5530" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5533" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5535" href="Tactic.MonoidSolver.html#5362" class="Bound">z</a><a id="5536" class="Symbol">)</a> <a id="5538" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">≈⟨</a> <a id="5541" href="Algebra.Structures.html#1366" class="Function">∙-congˡ</a> <a id="5549" class="Symbol">(</a><a id="5550" href="Tactic.MonoidSolver.html#5230" class="Function">homo′</a> <a id="5556" href="Tactic.MonoidSolver.html#5359" class="Bound">y</a> <a id="5558" href="Tactic.MonoidSolver.html#5362" class="Bound">z</a><a id="5559" class="Symbol">)</a> <a id="5561" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">⟩</a>
    <a id="5567" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5569" href="Tactic.MonoidSolver.html#5354" class="Bound">x</a> <a id="5571" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5574" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5576" class="Symbol">(</a><a id="5577" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5579" href="Tactic.MonoidSolver.html#5359" class="Bound">y</a> <a id="5581" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5585" href="Tactic.MonoidSolver.html#5362" class="Bound">z</a><a id="5586" class="Symbol">)</a>  <a id="5589" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">≈⟨</a> <a id="5592" href="Tactic.MonoidSolver.html#5230" class="Function">homo′</a> <a id="5598" href="Tactic.MonoidSolver.html#5354" class="Bound">x</a> <a id="5600" class="Symbol">(</a><a id="5601" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5603" href="Tactic.MonoidSolver.html#5359" class="Bound">y</a> <a id="5605" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5609" href="Tactic.MonoidSolver.html#5362" class="Bound">z</a><a id="5610" class="Symbol">)</a> <a id="5612" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">⟩</a>
    <a id="5618" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5620" href="Tactic.MonoidSolver.html#5354" class="Bound">x</a> <a id="5622" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5626" class="Symbol">(</a><a id="5627" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5629" href="Tactic.MonoidSolver.html#5359" class="Bound">y</a> <a id="5631" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5635" href="Tactic.MonoidSolver.html#5362" class="Bound">z</a><a id="5636" class="Symbol">)</a>   <a id="5640" href="Relation.Binary.Reasoning.Base.Single.html#2564" class="Function Operator">∎</a>

  <a id="5645" href="Tactic.MonoidSolver.html#5645" class="Function">homo</a> <a id="5650" class="Symbol">:</a> <a id="5652" class="Symbol">∀</a> <a id="5654" href="Tactic.MonoidSolver.html#5654" class="Bound">x</a> <a id="5656" class="Symbol">→</a> <a id="5658" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5660" href="Tactic.MonoidSolver.html#5654" class="Bound">x</a> <a id="5662" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5665" href="Algebra.Bundles.html#6116" class="Field Operator">≈</a> <a id="5667" href="Tactic.MonoidSolver.html#4609" class="Function Operator">[</a> <a id="5669" href="Tactic.MonoidSolver.html#5654" class="Bound">x</a> <a id="5671" href="Tactic.MonoidSolver.html#4609" class="Function Operator">↓]</a>
  <a id="5676" href="Tactic.MonoidSolver.html#5645" class="Function">homo</a> <a id="5681" href="Tactic.MonoidSolver.html#4387" class="InductiveConstructor">ε′</a>       <a id="5690" class="Symbol">=</a> <a id="5692" href="Relation.Binary.Structures.html#1591" class="Function">refl</a>
  <a id="5699" href="Tactic.MonoidSolver.html#5645" class="Function">homo</a> <a id="5704" href="Tactic.MonoidSolver.html#4404" class="InductiveConstructor Operator">[</a> <a id="5706" href="Tactic.MonoidSolver.html#5706" class="Bound">x</a> <a id="5708" href="Tactic.MonoidSolver.html#4404" class="InductiveConstructor Operator">↑]</a>   <a id="5713" class="Symbol">=</a> <a id="5715" href="Algebra.Structures.html#4098" class="Function">identityʳ</a> <a id="5725" href="Tactic.MonoidSolver.html#5706" class="Bound">x</a>
  <a id="5729" href="Tactic.MonoidSolver.html#5645" class="Function">homo</a> <a id="5734" class="Symbol">(</a><a id="5735" href="Tactic.MonoidSolver.html#5735" class="Bound">x</a> <a id="5737" href="Tactic.MonoidSolver.html#4352" class="InductiveConstructor Operator">∙′</a> <a id="5740" href="Tactic.MonoidSolver.html#5740" class="Bound">y</a><a id="5741" class="Symbol">)</a> <a id="5743" class="Symbol">=</a> <a id="5745" href="Relation.Binary.Reasoning.Base.Single.html#1925" class="Function Operator">begin</a>
    <a id="5755" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5757" href="Tactic.MonoidSolver.html#5735" class="Bound">x</a> <a id="5759" href="Tactic.MonoidSolver.html#4352" class="InductiveConstructor Operator">∙′</a> <a id="5762" href="Tactic.MonoidSolver.html#5740" class="Bound">y</a> <a id="5764" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a>     <a id="5771" href="Relation.Binary.Reasoning.Base.Single.html#2479" class="Function Operator">≡⟨⟩</a>
    <a id="5779" href="Tactic.MonoidSolver.html#5044" class="Function Operator">[</a> <a id="5781" href="Tactic.MonoidSolver.html#5735" class="Bound">x</a> <a id="5783" href="Tactic.MonoidSolver.html#5044" class="Function Operator">⇓]′</a> <a id="5787" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5789" href="Tactic.MonoidSolver.html#5740" class="Bound">y</a> <a id="5791" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a>  <a id="5795" href="Relation.Binary.Reasoning.Setoid.html#1162" class="Function">≈˘⟨</a> <a id="5799" href="Tactic.MonoidSolver.html#5230" class="Function">homo′</a> <a id="5805" href="Tactic.MonoidSolver.html#5735" class="Bound">x</a> <a id="5807" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5809" href="Tactic.MonoidSolver.html#5740" class="Bound">y</a> <a id="5811" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5814" href="Relation.Binary.Reasoning.Setoid.html#1162" class="Function">⟩</a>
    <a id="5820" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5822" href="Tactic.MonoidSolver.html#5735" class="Bound">x</a> <a id="5824" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5827" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5829" href="Tactic.MonoidSolver.html#5176" class="Function Operator">[</a> <a id="5831" href="Tactic.MonoidSolver.html#5740" class="Bound">y</a> <a id="5833" href="Tactic.MonoidSolver.html#5176" class="Function Operator">⇓]</a> <a id="5836" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">≈⟨</a> <a id="5839" href="Algebra.Structures.html#1216" class="Function">∙-cong</a> <a id="5846" class="Symbol">(</a><a id="5847" href="Tactic.MonoidSolver.html#5645" class="Function">homo</a> <a id="5852" href="Tactic.MonoidSolver.html#5735" class="Bound">x</a><a id="5853" class="Symbol">)</a> <a id="5855" class="Symbol">(</a><a id="5856" href="Tactic.MonoidSolver.html#5645" class="Function">homo</a> <a id="5861" href="Tactic.MonoidSolver.html#5740" class="Bound">y</a><a id="5862" class="Symbol">)</a> <a id="5864" href="Relation.Binary.Reasoning.Setoid.html#1061" class="Function">⟩</a>
    <a id="5870" href="Tactic.MonoidSolver.html#4609" class="Function Operator">[</a> <a id="5872" href="Tactic.MonoidSolver.html#5735" class="Bound">x</a> <a id="5874" href="Tactic.MonoidSolver.html#4609" class="Function Operator">↓]</a> <a id="5877" href="Algebra.Bundles.html#6145" class="Field Operator">∙</a> <a id="5879" href="Tactic.MonoidSolver.html#4609" class="Function Operator">[</a> <a id="5881" href="Tactic.MonoidSolver.html#5740" class="Bound">y</a> <a id="5883" href="Tactic.MonoidSolver.html#4609" class="Function Operator">↓]</a> <a id="5886" href="Relation.Binary.Reasoning.Base.Single.html#2564" class="Function Operator">∎</a>

<a id="5889" class="Comment">----------------------------------------------------------------------</a>
<a id="5960" class="Comment">-- Helpers for reflection</a>
<a id="5986" class="Comment">----------------------------------------------------------------------</a>

<a id="getArgs"></a><a id="6058" href="Tactic.MonoidSolver.html#6058" class="Function">getArgs</a> <a id="6066" class="Symbol">:</a> <a id="6068" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="6073" class="Symbol">→</a> <a id="6075" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="6081" class="Symbol">(</a><a id="6082" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="6087" href="Data.Product.Base.html#1118" class="Function Operator">×</a> <a id="6089" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="6093" class="Symbol">)</a>
<a id="6095" href="Tactic.MonoidSolver.html#6058" class="Function">getArgs</a> <a id="6103" class="Symbol">(</a><a id="6104" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6108" class="Symbol">_</a> <a id="6110" href="Tactic.MonoidSolver.html#6110" class="Bound">xs</a><a id="6112" class="Symbol">)</a> <a id="6114" class="Symbol">=</a> <a id="6116" href="Tactic.MonoidSolver.html#6132" class="Function">go</a> <a id="6119" href="Tactic.MonoidSolver.html#6110" class="Bound">xs</a>
  <a id="6124" class="Keyword">where</a>
  <a id="6132" href="Tactic.MonoidSolver.html#6132" class="Function">go</a> <a id="6135" class="Symbol">:</a> <a id="6137" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="6142" class="Symbol">(</a><a id="6143" href="Agda.Builtin.Reflection.html#3679" class="Datatype">Arg</a> <a id="6147" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="6151" class="Symbol">)</a> <a id="6153" class="Symbol">→</a> <a id="6155" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="6161" class="Symbol">(</a><a id="6162" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="6167" href="Data.Product.Base.html#1118" class="Function Operator">×</a> <a id="6169" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="6173" class="Symbol">)</a>
  <a id="6177" href="Tactic.MonoidSolver.html#6132" class="Function">go</a> <a id="6180" class="Symbol">(</a><a id="6181" href="Reflection.AST.Argument.html#1304" class="InductiveConstructor">vArg</a> <a id="6186" href="Tactic.MonoidSolver.html#6186" class="Bound">x</a> <a id="6188" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="6190" href="Reflection.AST.Argument.html#1304" class="InductiveConstructor">vArg</a> <a id="6195" href="Tactic.MonoidSolver.html#6195" class="Bound">y</a> <a id="6197" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="6199" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="6201" class="Symbol">)</a> <a id="6203" class="Symbol">=</a> <a id="6205" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="6210" class="Symbol">(</a><a id="6211" href="Tactic.MonoidSolver.html#6186" class="Bound">x</a> <a id="6213" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="6215" href="Tactic.MonoidSolver.html#6195" class="Bound">y</a><a id="6216" class="Symbol">)</a>
  <a id="6220" href="Tactic.MonoidSolver.html#6132" class="CatchallClause Function">go</a><a id="6222" class="CatchallClause"> </a><a id="6223" class="CatchallClause Symbol">(</a><a id="6224" href="Tactic.MonoidSolver.html#6224" class="CatchallClause Bound">x</a><a id="6225" class="CatchallClause"> </a><a id="6226" href="Agda.Builtin.List.html#182" class="CatchallClause InductiveConstructor Operator">∷</a><a id="6227" class="CatchallClause"> </a><a id="6228" href="Tactic.MonoidSolver.html#6228" class="CatchallClause Bound">xs</a><a id="6230" class="CatchallClause Symbol">)</a>               <a id="6246" class="Symbol">=</a> <a id="6248" href="Tactic.MonoidSolver.html#6132" class="Function">go</a> <a id="6251" href="Tactic.MonoidSolver.html#6228" class="Bound">xs</a>
  <a id="6256" href="Tactic.MonoidSolver.html#6132" class="CatchallClause Function">go</a><a id="6258" class="CatchallClause"> </a><a id="6259" class="CatchallClause Symbol">_</a>                      <a id="6282" class="Symbol">=</a> <a id="6284" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>
<a id="6292" href="Tactic.MonoidSolver.html#6058" class="CatchallClause Function">getArgs</a><a id="6299" class="CatchallClause"> </a><a id="6300" class="CatchallClause Symbol">_</a> <a id="6302" class="Symbol">=</a> <a id="6304" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>

<a id="6313" class="Comment">----------------------------------------------------------------------</a>
<a id="6384" class="Comment">-- Getting monoid names</a>
<a id="6408" class="Comment">----------------------------------------------------------------------</a>

<a id="6480" class="Comment">-- We try to be flexible here, by matching two kinds of names.</a>
<a id="6543" class="Comment">-- The first is the field accessor for the monoid record itself.</a>
<a id="6608" class="Comment">-- However, users will likely want to use the solver with</a>
<a id="6666" class="Comment">-- expressions like:</a>
<a id="6687" class="Comment">--</a>
<a id="6690" class="Comment">--   xs ++ (ys ++ zs) ≡ (xs ++ ys) ++ zs</a>
<a id="6731" class="Comment">--</a>
<a id="6734" class="Comment">-- So we also evaluate the field accessor to find functions like ++.</a>

<a id="6804" class="Keyword">record</a> <a id="MonoidNames"></a><a id="6811" href="Tactic.MonoidSolver.html#6811" class="Record">MonoidNames</a> <a id="6823" class="Symbol">:</a> <a id="6825" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="6829" class="Keyword">where</a>
  <a id="6837" class="Keyword">field</a>
    <a id="MonoidNames.is-∙"></a><a id="6847" href="Tactic.MonoidSolver.html#6847" class="Field">is-∙</a> <a id="6852" class="Symbol">:</a> <a id="6854" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="6859" class="Symbol">→</a> <a id="6861" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a>
    <a id="MonoidNames.is-ε"></a><a id="6870" href="Tactic.MonoidSolver.html#6870" class="Field">is-ε</a> <a id="6875" class="Symbol">:</a> <a id="6877" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="6882" class="Symbol">→</a> <a id="6884" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a>

<a id="buildMatcher"></a><a id="6890" href="Tactic.MonoidSolver.html#6890" class="Function">buildMatcher</a> <a id="6903" class="Symbol">:</a> <a id="6905" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="6910" class="Symbol">→</a> <a id="6912" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="6918" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="6923" class="Symbol">→</a> <a id="6925" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="6930" class="Symbol">→</a> <a id="6932" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a>
<a id="6937" href="Tactic.MonoidSolver.html#6890" class="Function">buildMatcher</a> <a id="6950" href="Tactic.MonoidSolver.html#6950" class="Bound">n</a> <a id="6952" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>  <a id="6961" href="Tactic.MonoidSolver.html#6961" class="Bound">x</a> <a id="6963" class="Symbol">=</a> <a id="6965" href="Tactic.MonoidSolver.html#6950" class="Bound">n</a> <a id="6967" href="Agda.Builtin.Reflection.html#522" class="Primitive Operator">Name.≡ᵇ</a> <a id="6975" href="Tactic.MonoidSolver.html#6961" class="Bound">x</a>
<a id="6977" href="Tactic.MonoidSolver.html#6890" class="Function">buildMatcher</a> <a id="6990" href="Tactic.MonoidSolver.html#6990" class="Bound">n</a> <a id="6992" class="Symbol">(</a><a id="6993" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="6998" href="Tactic.MonoidSolver.html#6998" class="Bound">m</a><a id="6999" class="Symbol">)</a> <a id="7001" href="Tactic.MonoidSolver.html#7001" class="Bound">x</a> <a id="7003" class="Symbol">=</a> <a id="7005" href="Tactic.MonoidSolver.html#6990" class="Bound">n</a> <a id="7007" href="Agda.Builtin.Reflection.html#522" class="Primitive Operator">Name.≡ᵇ</a> <a id="7015" href="Tactic.MonoidSolver.html#7001" class="Bound">x</a> <a id="7017" href="Data.Bool.Base.html#1053" class="Function Operator">∨</a> <a id="7019" href="Tactic.MonoidSolver.html#6998" class="Bound">m</a> <a id="7021" href="Agda.Builtin.Reflection.html#522" class="Primitive Operator">Name.≡ᵇ</a> <a id="7029" href="Tactic.MonoidSolver.html#7001" class="Bound">x</a>

<a id="findMonoidNames"></a><a id="7032" href="Tactic.MonoidSolver.html#7032" class="Function">findMonoidNames</a> <a id="7048" class="Symbol">:</a> <a id="7050" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="7055" class="Symbol">→</a> <a id="7057" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="7060" href="Tactic.MonoidSolver.html#6811" class="Record">MonoidNames</a>
<a id="7072" href="Tactic.MonoidSolver.html#7032" class="Function">findMonoidNames</a> <a id="7088" href="Tactic.MonoidSolver.html#7088" class="Bound">mon</a> <a id="7092" class="Symbol">=</a> <a id="7094" class="Keyword">do</a>
  <a id="7099" href="Tactic.MonoidSolver.html#7099" class="Bound">∙-altName</a> <a id="7109" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7111" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="7121" class="Symbol">(</a><a id="7122" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="7126" class="Symbol">(</a><a id="7127" class="Keyword">quote</a> <a id="7133" href="Algebra.Bundles.html#6145" class="Field Operator">Monoid._∙_</a><a id="7143" class="Symbol">)</a> <a id="7145" class="Symbol">(</a><a id="7146" class="Number">2</a> <a id="7148" href="Reflection.AST.Term.html#2947" class="Function Operator">⋯⟅∷⟆</a> <a id="7153" href="Tactic.MonoidSolver.html#7088" class="Bound">mon</a> <a id="7157" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7161" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7163" class="Symbol">))</a>
  <a id="7168" href="Tactic.MonoidSolver.html#7168" class="Bound">ε-altName</a> <a id="7178" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7180" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="7190" class="Symbol">(</a><a id="7191" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="7195" class="Symbol">(</a><a id="7196" class="Keyword">quote</a> <a id="7202" href="Algebra.Bundles.html#6172" class="Field">Monoid.ε</a><a id="7210" class="Symbol">)</a>   <a id="7214" class="Symbol">(</a><a id="7215" class="Number">2</a> <a id="7217" href="Reflection.AST.Term.html#2947" class="Function Operator">⋯⟅∷⟆</a> <a id="7222" href="Tactic.MonoidSolver.html#7088" class="Bound">mon</a> <a id="7226" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7230" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7232" class="Symbol">))</a>
  <a id="7237" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="7242" class="Keyword">record</a>
    <a id="7253" class="Symbol">{</a> <a id="7255" href="Tactic.MonoidSolver.html#6847" class="Field">is-∙</a> <a id="7260" class="Symbol">=</a> <a id="7262" href="Tactic.MonoidSolver.html#6890" class="Function">buildMatcher</a> <a id="7275" class="Symbol">(</a><a id="7276" class="Keyword">quote</a> <a id="7282" href="Algebra.Bundles.html#6145" class="Field Operator">Monoid._∙_</a><a id="7292" class="Symbol">)</a> <a id="7294" class="Symbol">(</a><a id="7295" href="Reflection.AST.Term.html#2315" class="Function">getName</a> <a id="7303" href="Tactic.MonoidSolver.html#7099" class="Bound">∙-altName</a><a id="7312" class="Symbol">)</a>
    <a id="7318" class="Symbol">;</a> <a id="7320" href="Tactic.MonoidSolver.html#6870" class="Field">is-ε</a> <a id="7325" class="Symbol">=</a> <a id="7327" href="Tactic.MonoidSolver.html#6890" class="Function">buildMatcher</a> <a id="7340" class="Symbol">(</a><a id="7341" class="Keyword">quote</a> <a id="7347" href="Algebra.Bundles.html#6172" class="Field">Monoid.ε</a><a id="7355" class="Symbol">)</a>   <a id="7359" class="Symbol">(</a><a id="7360" href="Reflection.AST.Term.html#2315" class="Function">getName</a> <a id="7368" href="Tactic.MonoidSolver.html#7168" class="Bound">ε-altName</a><a id="7377" class="Symbol">)</a>
    <a id="7383" class="Symbol">}</a>

<a id="7386" class="Comment">----------------------------------------------------------------------</a>
<a id="7457" class="Comment">-- Building Expr</a>
<a id="7474" class="Comment">----------------------------------------------------------------------</a>

<a id="7546" class="Comment">-- We now define a function that takes an AST representing the LHS</a>
<a id="7613" class="Comment">-- or RHS of the equation to solve and converts it into an AST</a>
<a id="7676" class="Comment">-- respresenting the corresponding Expr.</a>

<a id="″ε″"></a><a id="7718" href="Tactic.MonoidSolver.html#7718" class="Function">″ε″</a> <a id="7722" class="Symbol">:</a> <a id="7724" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="7729" href="Tactic.MonoidSolver.html#7718" class="Function">″ε″</a> <a id="7733" class="Symbol">=</a> <a id="7735" class="Keyword">quote</a> <a id="7741" href="Tactic.MonoidSolver.html#4387" class="InductiveConstructor">ε′</a> <a id="7744" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="7746" href="Agda.Builtin.Reflection.html#4871" class="InductiveConstructor">con</a> <a id="7750" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="7752" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>

<a id="[_↑]′"></a><a id="7756" href="Tactic.MonoidSolver.html#7756" class="Function Operator">[_↑]′</a> <a id="7762" class="Symbol">:</a> <a id="7764" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="7769" class="Symbol">→</a> <a id="7771" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="7776" href="Tactic.MonoidSolver.html#7756" class="Function Operator">[</a> <a id="7778" href="Tactic.MonoidSolver.html#7778" class="Bound">t</a> <a id="7780" href="Tactic.MonoidSolver.html#7756" class="Function Operator">↑]′</a> <a id="7784" class="Symbol">=</a> <a id="7786" class="Keyword">quote</a> <a id="7792" href="Tactic.MonoidSolver.html#4404" class="InductiveConstructor Operator">[_↑]</a> <a id="7797" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="7799" href="Agda.Builtin.Reflection.html#4871" class="InductiveConstructor">con</a> <a id="7803" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="7805" class="Symbol">(</a><a id="7806" href="Tactic.MonoidSolver.html#7778" class="Bound">t</a> <a id="7808" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7812" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7814" class="Symbol">)</a>

<a id="7817" class="Keyword">module</a> <a id="7824" href="Tactic.MonoidSolver.html#7824" class="Module">_</a> <a id="7826" class="Symbol">(</a><a id="7827" href="Tactic.MonoidSolver.html#7827" class="Bound">names</a> <a id="7833" class="Symbol">:</a> <a id="7835" href="Tactic.MonoidSolver.html#6811" class="Record">MonoidNames</a><a id="7846" class="Symbol">)</a> <a id="7848" class="Keyword">where</a>

 <a id="7856" class="Keyword">open</a> <a id="7861" href="Tactic.MonoidSolver.html#6811" class="Module">MonoidNames</a> <a id="7873" href="Tactic.MonoidSolver.html#7827" class="Bound">names</a>

 <a id="7881" class="Keyword">mutual</a>
  <a id="7890" href="Tactic.MonoidSolver.html#7890" class="Function">″∙″</a> <a id="7894" class="Symbol">:</a> <a id="7896" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="7901" class="Symbol">(</a><a id="7902" href="Agda.Builtin.Reflection.html#3679" class="Datatype">Arg</a> <a id="7906" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="7910" class="Symbol">)</a> <a id="7912" class="Symbol">→</a> <a id="7914" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="7921" href="Tactic.MonoidSolver.html#7890" class="Function">″∙″</a> <a id="7925" class="Symbol">(</a><a id="7926" href="Tactic.MonoidSolver.html#7926" class="Bound">x</a> <a id="7928" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7932" href="Tactic.MonoidSolver.html#7932" class="Bound">y</a> <a id="7934" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7938" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7940" class="Symbol">)</a> <a id="7942" class="Symbol">=</a> <a id="7944" class="Keyword">quote</a> <a id="7950" href="Tactic.MonoidSolver.html#4352" class="InductiveConstructor Operator">_∙′_</a> <a id="7955" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="7957" href="Agda.Builtin.Reflection.html#4871" class="InductiveConstructor">con</a> <a id="7961" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="7963" href="Tactic.MonoidSolver.html#8066" class="Function">buildExpr</a> <a id="7973" href="Tactic.MonoidSolver.html#7926" class="Bound">x</a> <a id="7975" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7979" href="Tactic.MonoidSolver.html#8066" class="Function">buildExpr</a> <a id="7989" href="Tactic.MonoidSolver.html#7932" class="Bound">y</a> <a id="7991" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7995" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>
  <a id="8000" href="Tactic.MonoidSolver.html#7890" class="CatchallClause Function">″∙″</a><a id="8003" class="CatchallClause"> </a><a id="8004" class="CatchallClause Symbol">(</a><a id="8005" href="Tactic.MonoidSolver.html#8005" class="CatchallClause Bound">x</a><a id="8006" class="CatchallClause"> </a><a id="8007" href="Agda.Builtin.List.html#182" class="CatchallClause InductiveConstructor Operator">∷</a><a id="8008" class="CatchallClause"> </a><a id="8009" href="Tactic.MonoidSolver.html#8009" class="CatchallClause Bound">xs</a><a id="8011" class="CatchallClause Symbol">)</a>         <a id="8021" class="Symbol">=</a> <a id="8023" href="Tactic.MonoidSolver.html#7890" class="Function">″∙″</a> <a id="8027" href="Tactic.MonoidSolver.html#8009" class="Bound">xs</a>
  <a id="8032" href="Tactic.MonoidSolver.html#7890" class="CatchallClause Function">″∙″</a><a id="8035" class="CatchallClause"> </a><a id="8036" class="CatchallClause Symbol">_</a>                <a id="8053" class="Symbol">=</a> <a id="8055" href="Agda.Builtin.Reflection.html#5271" class="InductiveConstructor">unknown</a>

  <a id="8066" href="Tactic.MonoidSolver.html#8066" class="Function">buildExpr</a> <a id="8076" class="Symbol">:</a> <a id="8078" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="8083" class="Symbol">→</a> <a id="8085" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="8092" href="Tactic.MonoidSolver.html#8066" class="Function">buildExpr</a> <a id="8102" href="Tactic.MonoidSolver.html#8102" class="Bound">t</a><a id="8103" class="Symbol">@(</a><a id="8105" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="8109" href="Tactic.MonoidSolver.html#8109" class="Bound">n</a> <a id="8111" href="Tactic.MonoidSolver.html#8111" class="Bound">xs</a><a id="8113" class="Symbol">)</a> <a id="8115" class="Symbol">=</a>
    <a id="8121" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8124" href="Tactic.MonoidSolver.html#6847" class="Field">is-∙</a> <a id="8129" href="Tactic.MonoidSolver.html#8109" class="Bound">n</a>
      <a id="8137" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8142" href="Tactic.MonoidSolver.html#7890" class="Function">″∙″</a> <a id="8146" href="Tactic.MonoidSolver.html#8111" class="Bound">xs</a>
    <a id="8153" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="8158" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8161" href="Tactic.MonoidSolver.html#6870" class="Field">is-ε</a> <a id="8166" href="Tactic.MonoidSolver.html#8109" class="Bound">n</a>
      <a id="8174" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8179" href="Tactic.MonoidSolver.html#7718" class="Function">″ε″</a>
    <a id="8187" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
      <a id="8198" href="Tactic.MonoidSolver.html#7756" class="Function Operator">[</a> <a id="8200" href="Tactic.MonoidSolver.html#8102" class="Bound">t</a> <a id="8202" href="Tactic.MonoidSolver.html#7756" class="Function Operator">↑]′</a>
  <a id="8208" href="Tactic.MonoidSolver.html#8066" class="Function">buildExpr</a> <a id="8218" href="Tactic.MonoidSolver.html#8218" class="Bound">t</a><a id="8219" class="Symbol">@(</a><a id="8221" href="Agda.Builtin.Reflection.html#4871" class="InductiveConstructor">con</a> <a id="8225" href="Tactic.MonoidSolver.html#8225" class="Bound">n</a> <a id="8227" href="Tactic.MonoidSolver.html#8227" class="Bound">xs</a><a id="8229" class="Symbol">)</a> <a id="8231" class="Symbol">=</a>
    <a id="8237" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8240" href="Tactic.MonoidSolver.html#6847" class="Field">is-∙</a> <a id="8245" href="Tactic.MonoidSolver.html#8225" class="Bound">n</a>
      <a id="8253" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8258" href="Tactic.MonoidSolver.html#7890" class="Function">″∙″</a> <a id="8262" href="Tactic.MonoidSolver.html#8227" class="Bound">xs</a>
    <a id="8269" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="8274" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8277" href="Tactic.MonoidSolver.html#6870" class="Field">is-ε</a> <a id="8282" href="Tactic.MonoidSolver.html#8225" class="Bound">n</a>
      <a id="8290" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8295" href="Tactic.MonoidSolver.html#7718" class="Function">″ε″</a>
    <a id="8303" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="8308" href="Tactic.MonoidSolver.html#7756" class="Function Operator">[</a> <a id="8310" href="Tactic.MonoidSolver.html#8218" class="Bound">t</a> <a id="8312" href="Tactic.MonoidSolver.html#7756" class="Function Operator">↑]′</a>
  <a id="8318" href="Tactic.MonoidSolver.html#8066" class="CatchallClause Function">buildExpr</a><a id="8327" class="CatchallClause"> </a><a id="8328" href="Tactic.MonoidSolver.html#8328" class="CatchallClause Bound">t</a> <a id="8330" class="Symbol">=</a> <a id="8332" class="Keyword">quote</a> <a id="8338" href="Tactic.MonoidSolver.html#4404" class="InductiveConstructor Operator">[_↑]</a> <a id="8343" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="8345" href="Agda.Builtin.Reflection.html#4871" class="InductiveConstructor">con</a> <a id="8349" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="8351" class="Symbol">(</a><a id="8352" href="Tactic.MonoidSolver.html#8328" class="Bound">t</a> <a id="8354" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8358" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="8360" class="Symbol">)</a>

<a id="8363" class="Comment">----------------------------------------------------------------------</a>
<a id="8434" class="Comment">-- Constructing the solution</a>
<a id="8463" class="Comment">----------------------------------------------------------------------</a>

<a id="8535" class="Comment">-- This function joins up the two homomorphism proofs. It constructs</a>
<a id="8604" class="Comment">-- a proof of the following form:</a>
<a id="8638" class="Comment">--</a>
<a id="8641" class="Comment">--   trans (sym (homo x)) (homo y)</a>
<a id="8676" class="Comment">--</a>
<a id="8679" class="Comment">-- where x and y are the Expr representations of each side of the</a>
<a id="8745" class="Comment">-- goal equation.</a>

<a id="constructSoln"></a><a id="8764" href="Tactic.MonoidSolver.html#8764" class="Function">constructSoln</a> <a id="8778" class="Symbol">:</a> <a id="8780" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="8785" class="Symbol">→</a> <a id="8787" href="Tactic.MonoidSolver.html#6811" class="Record">MonoidNames</a> <a id="8799" class="Symbol">→</a> <a id="8801" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="8806" class="Symbol">→</a> <a id="8808" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="8813" class="Symbol">→</a> <a id="8815" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="8820" href="Tactic.MonoidSolver.html#8764" class="Function">constructSoln</a> <a id="8834" href="Tactic.MonoidSolver.html#8834" class="Bound">mon</a> <a id="8838" href="Tactic.MonoidSolver.html#8838" class="Bound">names</a> <a id="8844" href="Tactic.MonoidSolver.html#8844" class="Bound">lhs</a> <a id="8848" href="Tactic.MonoidSolver.html#8848" class="Bound">rhs</a> <a id="8852" class="Symbol">=</a>
  <a id="8856" class="Keyword">quote</a> <a id="8862" href="Relation.Binary.Structures.html#1643" class="Function">Monoid.trans</a> <a id="8875" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="8877" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="8881" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="8883" class="Number">2</a> <a id="8885" href="Reflection.AST.Term.html#2947" class="Function Operator">⋯⟅∷⟆</a> <a id="8890" href="Tactic.MonoidSolver.html#8834" class="Bound">mon</a> <a id="8894" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a>
    <a id="8902" class="Symbol">(</a><a id="8903" class="Keyword">quote</a> <a id="8909" href="Relation.Binary.Structures.html#1617" class="Function">Monoid.sym</a> <a id="8920" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="8922" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="8926" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="8928" class="Number">2</a> <a id="8930" href="Reflection.AST.Term.html#2947" class="Function Operator">⋯⟅∷⟆</a> <a id="8935" href="Tactic.MonoidSolver.html#8834" class="Bound">mon</a> <a id="8939" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a>
       <a id="8950" class="Symbol">(</a><a id="8951" class="Keyword">quote</a> <a id="8957" href="Tactic.MonoidSolver.html#5645" class="Function">homo</a> <a id="8962" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="8964" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="8968" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="8970" class="Number">2</a> <a id="8972" href="Reflection.AST.Term.html#2947" class="Function Operator">⋯⟅∷⟆</a> <a id="8977" href="Tactic.MonoidSolver.html#8834" class="Bound">mon</a> <a id="8981" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8985" href="Tactic.MonoidSolver.html#8066" class="Function">buildExpr</a> <a id="8995" href="Tactic.MonoidSolver.html#8838" class="Bound">names</a> <a id="9001" href="Tactic.MonoidSolver.html#8844" class="Bound">lhs</a> <a id="9005" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9009" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="9011" class="Symbol">)</a> <a id="9013" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9017" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="9019" class="Symbol">)</a>
    <a id="9025" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a>
    <a id="9033" class="Symbol">(</a><a id="9034" class="Keyword">quote</a> <a id="9040" href="Tactic.MonoidSolver.html#5645" class="Function">homo</a> <a id="9045" href="Function.Base.html#4339" class="Function Operator">⟨</a> <a id="9047" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="9051" href="Function.Base.html#4339" class="Function Operator">⟩</a> <a id="9053" class="Number">2</a> <a id="9055" href="Reflection.AST.Term.html#2947" class="Function Operator">⋯⟅∷⟆</a> <a id="9060" href="Tactic.MonoidSolver.html#8834" class="Bound">mon</a> <a id="9064" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9068" href="Tactic.MonoidSolver.html#8066" class="Function">buildExpr</a> <a id="9078" href="Tactic.MonoidSolver.html#8838" class="Bound">names</a> <a id="9084" href="Tactic.MonoidSolver.html#8848" class="Bound">rhs</a> <a id="9088" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9092" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="9094" class="Symbol">)</a> <a id="9096" href="Reflection.AST.Argument.html#1696" class="InductiveConstructor Operator">⟨∷⟩</a>
    <a id="9104" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>

<a id="9108" class="Comment">----------------------------------------------------------------------</a>
<a id="9179" class="Comment">-- Macro</a>
<a id="9188" class="Comment">----------------------------------------------------------------------</a>

<a id="solve-macro"></a><a id="9260" href="Tactic.MonoidSolver.html#9260" class="Function">solve-macro</a> <a id="9272" class="Symbol">:</a> <a id="9274" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9279" class="Symbol">→</a> <a id="9281" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9286" class="Symbol">→</a> <a id="9288" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="9291" class="Symbol">_</a>
<a id="9293" href="Tactic.MonoidSolver.html#9260" class="Function">solve-macro</a> <a id="9305" href="Tactic.MonoidSolver.html#9305" class="Bound">mon</a> <a id="9309" href="Tactic.MonoidSolver.html#9309" class="Bound">hole</a> <a id="9314" class="Symbol">=</a> <a id="9316" class="Keyword">do</a>
  <a id="9321" href="Tactic.MonoidSolver.html#9321" class="Bound">hole′</a> <a id="9327" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9329" href="Agda.Builtin.Reflection.html#8555" class="Postulate">inferType</a> <a id="9339" href="Tactic.MonoidSolver.html#9309" class="Bound">hole</a> <a id="9344" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="9348" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a>
  <a id="9360" href="Tactic.MonoidSolver.html#9360" class="Bound">names</a> <a id="9366" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9368" href="Tactic.MonoidSolver.html#7032" class="Function">findMonoidNames</a> <a id="9384" href="Tactic.MonoidSolver.html#9305" class="Bound">mon</a>
  <a id="9390" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="9395" class="Symbol">(</a><a id="9396" href="Tactic.MonoidSolver.html#9396" class="Bound">lhs</a> <a id="9400" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="9402" href="Tactic.MonoidSolver.html#9402" class="Bound">rhs</a><a id="9405" class="Symbol">)</a> <a id="9407" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9409" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="9414" class="Symbol">(</a><a id="9415" href="Tactic.MonoidSolver.html#6058" class="Function">getArgs</a> <a id="9423" href="Tactic.MonoidSolver.html#9321" class="Bound">hole′</a><a id="9428" class="Symbol">)</a>
    <a id="9434" class="Keyword">where</a> <a id="9440" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a> <a id="9448" class="Symbol">→</a> <a id="9450" href="Agda.Builtin.Reflection.html#8492" class="Postulate">typeError</a> <a id="9460" class="Symbol">(</a><a id="9461" href="Agda.Builtin.Reflection.html#7931" class="InductiveConstructor">termErr</a> <a id="9469" href="Tactic.MonoidSolver.html#9321" class="Bound">hole′</a> <a id="9475" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="9477" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="9479" class="Symbol">)</a>
  <a id="9483" class="Keyword">let</a> <a id="9487" href="Tactic.MonoidSolver.html#9487" class="Bound">soln</a> <a id="9492" class="Symbol">=</a> <a id="9494" href="Tactic.MonoidSolver.html#8764" class="Function">constructSoln</a> <a id="9508" href="Tactic.MonoidSolver.html#9305" class="Bound">mon</a> <a id="9512" href="Tactic.MonoidSolver.html#9360" class="Bound">names</a> <a id="9518" href="Tactic.MonoidSolver.html#9396" class="Bound">lhs</a> <a id="9522" href="Tactic.MonoidSolver.html#9402" class="Bound">rhs</a>
  <a id="9528" href="Agda.Builtin.Reflection.html#8452" class="Postulate">unify</a> <a id="9534" href="Tactic.MonoidSolver.html#9309" class="Bound">hole</a> <a id="9539" href="Tactic.MonoidSolver.html#9487" class="Bound">soln</a>

<a id="9545" class="Keyword">macro</a>
  <a id="solve"></a><a id="9553" href="Tactic.MonoidSolver.html#9553" class="Function">solve</a> <a id="9559" class="Symbol">:</a> <a id="9561" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9566" class="Symbol">→</a> <a id="9568" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9573" class="Symbol">→</a> <a id="9575" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="9578" class="Symbol">_</a>
  <a id="9582" href="Tactic.MonoidSolver.html#9553" class="Function">solve</a> <a id="9588" class="Symbol">=</a> <a id="9590" href="Tactic.MonoidSolver.html#9260" class="Function">solve-macro</a>
</pre></body></html>